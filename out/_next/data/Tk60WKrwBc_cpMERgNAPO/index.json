{"pageProps":{"blogPosts":[{"title":"AES: How the Most Advanced Encryption Actually Works","pubDate":"2021-07-13 07:12:05","link":"https://devsafehouse.medium.com/aes-how-the-most-advanced-encryption-actually-works-b6341c44edb9?source=rss-2264614a31c6------2","guid":"https://medium.com/p/b6341c44edb9","author":"SafeHouse","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*0tm9NZW_Q2--zb3SR6JIjA.png","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0tm9NZW_Q2--zb3SR6JIjA.png\"><figcaption>Image source: <a href=\"https://www.venafi.com/blog/what-are-best-use-cases-symmetric-vs-asymmetric-encryption\">https://www.venafi.com/blog/what-are-best-use-cases-symmetric-vs-asymmetric-encryption</a></figcaption></figure><p>Governments, militaries, banks and corporations rely on it. Itâ€™s responsible for securing most, if not all of your personal and financial data. There are special CPU instructions for it. It is the only cryptographic algorithm approved by theÂ NSA.</p>\n<p>Weâ€™re of course talking about the Advanced Encryption Standard (AES), the most commonplace and secure symmetric encryption algorithm yet developed.</p>\n<p>This will be the longest article we write for the time being ğŸ˜Š. Weâ€™re going to take a deep dive into how this algorithm works. Modern cryptographic algorithms are by no means trivial; they use concepts from advanced mathematics to achieve a high level of security. But we donâ€™t expect you to be a mathematician.</p>\n<p>While there are many articles about AES, most of them are either too technical or leave out important information. With this article we hope to strike the perfect balance between comprehensiveness and accessibility. However, we must admit that this article will require some level of comfort with math, as mathematical concepts are introduced here.</p>\n<p>It must be stated that you should not try to implement AES by yourself in a production application, or risk a <a href=\"https://en.wikipedia.org/wiki/Side-channel_attack\">side channel attack</a>. Use the many free <a href=\"https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries\">cryptographic libraries</a> that offer tested implementations of whatever algorithms youÂ need.</p>\n<h3>The Basics</h3>\n<p>First, a brief refresher on what AESÂ is.</p>\n<p>AES is not the name of the algorithm itself, but a title awarded by the National Institute of Standards and Technology (NIST) to the algorithm they deemed to be the de facto standard for encryption. The actual name of the algorithm is <em>Rijndael</em>, and it was selected by the NIST over a number of algorithms to replace the former standard, known as DES (Data Encryption Standard). Rijndael was approved by the NIST in 2001 and adopted by the US government in 2002. It remains the standard cipher used by the US government and institutions across theÂ world.</p>\n<p>AES is a <em>symmetric cipher</em>, which means that a single key is used to encrypt <em>and</em> decrypt the same data. AES can be performed with the following key sizes: <strong>128 bits, 196 bits and 256 bits</strong>. Generally, increasing the key size also increases the level of security. Rijndael works for any key size that is a multiple of 32 bits, but the NIST chose specific sizes (and other parameters) that balance performance and security.</p>\n<p>It is also a <em>block cipher</em>, meaning that the data is divided into blocks before encryption. AES divides plaintext into blocks of 16 bytes (128Â bits).</p>\n<h3>Algorithm Overview</h3>\n<p>The gist of AES is this: we arrange each block of the plaintext into a 4x4 matrix and repeatedly perform a set of operations on it. We call each iteration a <em>round</em>, and we perform <strong>10, 12 or 14 rounds</strong> depending on the key length (this is another parameter chosen byÂ NIST):</p>\n<ul>\n<li>10 rounds for a 128-bitÂ key</li>\n<li>12 rounds for a 196-bitÂ key</li>\n<li>14 rounds for a 256 bitÂ key</li>\n</ul>\n<p>For each round, we generate a <em>round key </em>from the main key using the <em>Rijndael Key Schedule</em>.</p>\n<p>There are four operations on the 4x4 matrix that we willÂ define:</p>\n<ul>\n<li>subBytes()</li>\n<li>shiftRows()</li>\n<li>mixColumns()</li>\n<li>addRoundKey()</li>\n</ul>\n<p>Not every round of operations is the same; for the first round, we only add the round key, and for the last round we omit the mixColumns() step. So the pseudocode for the AES algorithm might look something likeÂ this:</p>\n<pre>function AESencrypt(plaintext, key) {<br><br>  blocks := divideIntoBlocks(plaintext);<br>  roundKeys = getRoundKeys(key)</pre>\n<pre>  for (block in blocks) {</pre>\n<pre>    //first round<br>    addRoundKey(roundKeys[0], block);</pre>\n<pre>    //intermediate rounds<br>    for (8, 10 or 12 rounds) {<br>      subBytes(block);<br>      shiftRows(block);<br>      mixColumns(block);<br>      addRoundKey(roundKeys[..], block);<br>    }</pre>\n<pre>    //last round<br>    subBytes(block);<br>    shiftRows(block);<br>    addRoundKey(roundKeys[numRounds - 1], block);</pre>\n<pre>  }</pre>\n<pre>  ciphertext := reassemble(blocks);<br>  return ciphertext;</pre>\n<pre>}</pre>\n<h3>Mathematical Background</h3>\n<p>This section may appear rather esoteric. We told you we would explain AES in detail and we werenâ€™t lying. Luckily, we believe that the concepts in this section can be understood with only high-school level math and basic programming experience. Donâ€™t let the fancy words throw youÂ off!</p>\n<p>Letâ€™s introduce a concept in abstract algebra called a <em>Galois field</em> or <em>finite field</em>. A <em>field</em> is a set (meaning a collection of objects) with operations that act on the set and behave similarly to addition, subtraction, multiplication and division. In other words, the operations satisfy a number of properties that also hold true for addition/subtraction/multiplication/division over the rational numbers. In fact, the rational and real numbers with these four operations qualify as a field. The <em>finite</em> qualifier just means that the set has a finite number of elements.</p>\n<p>We wonâ€™t go into the specific definition of a field. Just think of it as a set of numbers where addition, subtraction, multiplication and division are redefined.</p>\n<p>AES uses a specific Galois field, which we will call <em>Rijndaelâ€™s finite field</em>, to perform many essential operations. In particular, it uses GF(2â¸) with irreducible polynomial <em>x</em>â¸ +<em> x</em>â´ + <em>x</em>Â³ + <em>x</em> + 1. Youâ€™ll understand what this means in aÂ bit.</p>\n<p>The Galois field GF(<em>pâ¿</em>), where <em>p</em> is prime and <em>n</em> is a positive integer, denotes the field with <em>pâ¿ </em>elements<em>. </em>For example, the field GF(8) (or GF(2Â³)) contains all integers from 0 to 7. An important property of Galois fields is that the elements of the field GF(<em>pâ¿</em>) are <strong>all polynomials of degree less than n with non-negative coefficients, evaluated at p</strong><em>. p</em> is called the <em>characteristic</em> of theÂ field.</p>\n<p>Letâ€™s look at GF(8), or GF(2Â³), again. GF(2Â³) contains {0, 1, 2, 3, 4, 5, 6, 7}, which can be equivalently represented as {0, 1, 2, 2 + 1, 2Â², 2Â²+ 1, 2Â²+ 2, 2Â²+ 2 + 1}, or {0, 1, <em>x</em>, <em>x</em>+ 1, <em>x</em>Â², <em>x</em>Â² + 1, <em>x</em>Â² + <em>x</em>, <em>x</em>Â² + <em>x</em>+ 1} where <em>x</em> =Â 2.</p>\n<p>With this notation out of the way, we can now explain how addition/subtraction/multiplication/division works with GaloisÂ fields.</p>\n<h4><strong>Addition/Subtraction</strong></h4>\n<p>Suppose we want to add elements <em>a</em> and <em>b</em> of GF(<em>pâ¿</em>). First, convert them to their polynomial forms, that is, write them as sums of powers of <em>p</em>. Then we add the polynomials together, but with a caveat: for each coefficient <em>a_k</em> in <em>a(p)</em>, <em>b_k</em> in <em>b(p)</em>, the resulting coefficient <em>c_k </em>is equal to <em>a_k</em> + <em>b_k</em> mod <em>p</em>. For subtraction, the formula is <em>c_k</em> = <em>a_k</em>â€Šâ€”â€Š<em>b_k</em> modÂ <em>p</em>.</p>\n<p>We apologize for Mediumâ€™s lack of support for mathematical expressions. Here are the formulas again inÂ LaTeX:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/544/1*b32ra3kUxYZx0PAk-fBF0g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/584/1*-XPMYNDqSAghS8q8jizwpA.png\"></figure><p>â€œmodâ€ of course stands for modulo, which in most programming languages is written as â€œ%â€. Letâ€™s look at anÂ example:</p>\n<p>74 + 26 in GF(3â´) = (2 * 3Â³ + 2 * 3Â² + 2 * 1) + (2 * 3Â² + 2 * 3 + 2 *Â 1)</p>\n<p>= (2 * 3Â³ + 4 * 3Â² + 2 * 3 + 4 * 1) = (2 * 3Â³ + 3Â² + 6 + 1) =Â <strong>70</strong></p>\n<p>Notice that 4 * 3Â² became 3Â² and 4 * 1 became 1 because of the modulo operation on the coefficients.</p>\n<p>The Rijndael field GF(2â¸), as well as all fields with characteristic 2, share a property that makes them well suited for computers: <strong>addition and subtraction are equivalent to the bitwise exclusive or (XOR/âŠ•) operation.</strong> This works because <strong>each term in the polynomial represents a bit.</strong> Here is another example to demonstrate thisÂ fact:</p>\n<p>15 + 12 in GF(2â´) = (2Â³ + 2Â² + 2 + 1) + (2Â³ +Â 2Â²)</p>\n<p>= (2 * 2Â³ + 2 * 2Â² + 2 + 1) = (2 + 1) =Â <strong>3</strong></p>\n<p>15 âŠ• 12 = 0b1111 âŠ• 0b1100 = 0b0011 =Â <strong>3</strong></p>\n<p>Addition in Galois fields is often referred to as â€œcarryless addition.â€ We add each set of digits independently modulo <em>p</em>. Note that in the example above, the first set of digits adds to 2 mod 2 = 0, while the second set adds to 7 mod 2 =Â 3.</p>\n<h4><strong>Multiplication</strong></h4>\n<p>In order to multiply two polynomials <em>a(p)</em> and <em>b(p)</em> in GF(<em>pâ¿</em>), we need to chose a third polynomial <em>m(p) </em>that <em>cannot be factored</em> and has a degree of at least <em>n</em>. We call m(p) the irreducible polynomial.</p>\n<p>To multiply <em>a(p)</em> and <em>b(p) in </em>GF(<em>pâ¿</em>) we perform the following steps:</p>\n<ul>\n<li>Multiply <em>a(p)</em> and <em>b(p) </em>likeÂ normal</li>\n<li>Reduce the coefficients of the resulting polynomial moduloÂ p.</li>\n<li>Reduce the entire polynomial mod <em>m(p). </em>This is so our final answer stays less than<em>Â pâ¿.</em>\n</li>\n</ul>\n<p>The final step can be performed using polynomial long division. <strong>However, this is no ordinary division<em>.</em> Every arithmetic operation we perform during the process must be the finite fieldâ€™s version.</strong> In the case of GF(2â¸), every time we perform â€œsubtractionâ€, we actually perform the XOR operation. Representing the polynomials as binary strings will be helpful for thisÂ step.</p>\n<p>Letâ€™s perform 193 * 56 in GF(2â¸) and with <em>m(p)</em> = <em>x</em>â¸ +<em> x</em>â´ + <em>x</em>Â³ + <em>x</em> + 1 (Rijndaelâ€™s field):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rc1od0FZUReYTN0q6MJAow.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QdgLMbTc2cpGQEC3UXjZfw.png\"></figure><p>If multiplication in finite fields seems complicated, donâ€™t worry! With Rijndaelâ€™s field, the multiplication algorithm can be greatly optimized beyond what is described above. Below is a pseudocode implementation:</p>\n<pre>function gmul(a : byte, b : byte) {</pre>\n<pre>  p : byte = 0x00;<br><br>  for (8 rounds) {</pre>\n<pre>    //if low bit of b is set<br>    if ((b &amp; 1) != 0) {<br>      p = p âŠ• a;<br>    }<br><br>    //true if the high bit of a is set<br>    h : bool = (a &amp; 0x80) != 0;</pre>\n<pre>    a = a &lt;&lt; 1; //shift left<br><br>    if (h) {<br>      a = a âŠ• 0x1B; //value of the polynomial m(p) (0x11B) with the high bit removed<br>    }</pre>\n<pre>    b = b &gt;&gt; 1; //right shift</pre>\n<pre>   return p;</pre>\n<pre>  }  <br>}</pre>\n<h4>The Multiplicative Inverse/Division</h4>\n<p>The multiplicative inverse of a polynomial a(p) is the polynomial b(p) such that a(p) * b(p) mod m(p) = 1. Multiplicative inverses can be found by applying the inverse of the algorithm above. Division is simply a matter of multiplying the first operand by the multiplicative inverse of theÂ second.</p>\n<h4><strong>Whatâ€™s theÂ point?</strong></h4>\n<p>Why does AES borrow concepts from finite field theory. The main reason is performance. Remember that â€œadditionâ€ in GF(2â¸) is the same as the XOR operation. Also consider that there is no need to worry about overflow/underflow, because the inputs and outputs of the operations are restricted to the numbersÂ 0â€“255.</p>\n<p>Multiplication is less complicated than it looks. To put things in perspective, consider how computers perform normal multiplication at the lowest level: through repeated bit shifts and additions (of course, we donâ€™t have special circuitry to perform GF(2â¸) arithmetic). Finally, multiplication by 2 and 3 is very easy to optimize. This will become important later.</p>\n<pre>//multiply by 2 in GF(2^8)<br>function gmul2(a : byte) {</pre>\n<pre>  h : byte = a &amp; 0x80; //high bit</pre>\n<pre>  b : byte = a &lt;&lt; 1;</pre>\n<pre>  if (h == 0x80) b = b âŠ• 0x1b;</pre>\n<pre>  return b; </pre>\n<pre>}</pre>\n<pre>//multiply by 3 in GF(2^8)<br>function gmul3(a : byte) {</pre>\n<pre>  return a âŠ• gmul2(a);</pre>\n<pre>}</pre>\n<h3>Key Expansion</h3>\n<p>Weâ€™re done with background! Now itâ€™s time to look into the nitty-gritty of what AES actuallyÂ does.</p>\n<p>Before any encryption takes place, separate 128-bit keys must be generated for each round. Rijndael uses a specific algorithm to generate roundÂ keys.</p>\n<p>The Rijndael key schedule performs a number of operations:</p>\n<p><strong>rotate():</strong> rotates a 32-bit (4 byte) word 8 bits to the left. As an example: rotate(0xab157c9e) = 0x157c9eab.</p>\n<p><strong>rcon():</strong> exponentiates (repeatedly multiplies) 2 to a specified value in Rijndaelâ€™s finite field. This operation can be described by the pseudocode below. However, we will only need to use a maximum of 11 rcon() values, so a lookup table is sufficient.</p>\n<pre>function rcon(value : unsigned int) {</pre>\n<pre>  c : byte = 1;<br><br>  if (value == 0) return 0;<br>  while (value != 1) {<br>    c = gmul(c, 2);<br>    value--;<br>  }</pre>\n<pre>  return c;</pre>\n<pre>}</pre>\n<p>We have not yet explained how exponentiation works for finite fields. In short, it works very similarly to normal mathematics. We encourage curious readers to do their own research if they want to learnÂ more.</p>\n<p><strong>sbox():</strong> another operation in Rijndaelâ€™s field, usually implemented with the following lookupÂ table:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jS3HSAr5mIotBFA0EXgW1A.png\"></figure><p>Mathematically, sbox() is a two part operation. First, we take the multiplicative inverse of the input. The result is represented as an eight-element vector (one for each bit) and undergoes the following transformation:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-l0Y4dkfLh-KEpUlNuoy_Q.png\"></figure><p>The entire process is performed with Rijndaelâ€™s finite field arithmetic. So at the end, for example, the byte 0b11000110 is not added, but <strong>XORâ€™ed</strong> with the matrix-vector product. This transformation is more succinctly represented as a series of XORs and left bitwise rotations likeÂ so:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hn53zg152FwaSqwu6ECvyQ.png\"></figure><p>The sbox() operation heavily contributes to the security of AES as a whole. It is resistant to <strong>linear cryptoanalysis</strong> in that it is hard to approximate with a linear transformation. It is also resistant to <strong>differential cryptoanalysis</strong> in that there seems to be no correlation between how the input changes and how the output changes. Finally, sbox() is special in that there are no <strong>fixed points</strong>, i.e. there are no situations where the input equals theÂ output.</p>\n<p>The key expansion algorithm works mainly on 32-bit words instead of bytes. For the future, we will define <strong>subWord() </strong>as the application of sbox() on each byte of aÂ word.</p>\n<h4>The Key Expansion Algorithm</h4>\n<p>Onto the actual key-generation algorithm. Letâ€™s define some constants before we take a look at theÂ steps:</p>\n<ul>\n<li>Let K[0] thru K[N-1] represent the 32-bit words of the originalÂ key.</li>\n<li>Let N equal the length of the original key in 32-bit words <strong>(4, 6, or 8 for a 128, 192 or 256-bit key respectively).</strong>\n</li>\n<li>Let R equal the number of rounds <strong>(10, 12, or 15 for a 128, 192 or 256-bit key respectively).</strong>\n</li>\n<li>Let W[0] thru W[4R-1] represent the 32-bit words comprising all of the round keys. Letâ€™s call this the expandedÂ key.</li>\n</ul>\n<p>The key expansion algorithm iterates through all of the 32-bit words W[0] thru W[4R-1]. When we want a specific round key, we combine the four words (128 bits) from of the expanded key corresponding to that round. For example, the Round 3 Key comprises of W[8] thruÂ W[11].</p>\n<p>The algorithm goes likeÂ this:</p>\n<pre>for (i from 0 to 4R - 1) {</pre>\n<pre>  //The first words (W[0] thru W[N-1]) are equal to the words of the original key.<br>  //For a 128-bit key, this means that the first round key is equal to the original key.<br>  if (0 &lt; i &lt; N) W[i] = K[i];</pre>\n<pre>  //Perform operations on the last word of each N-length cycle before XOR-ing.<br>  else if (i &gt;= N and i == 0 mod N)<br>    W[i] = W[i-N] <strong>âŠ• </strong>subWord(rotate(W[i-1])) <strong>âŠ• </strong>rcon(i/N);</pre>\n<pre>  //For a 256-bit key length only.<br>  else if (i &gt;= N and N == 8 and i == 4 mod N)<br>    W[i] = W[i-N] <strong>âŠ• </strong>subWord(W[i-1])<strong>;</strong></pre>\n<pre>  //Typical case<br>  else W[i] = W[i-N] <strong>âŠ• </strong>W[i-1];</pre>\n<pre>}</pre>\n<p>The gist of the algorithm is this: generally, each word is the previous word XORâ€™ed with the word N places behind it. But every N words, we perform various GF(2â¸) operations on the word N places behind before the XOR-ing takesÂ place.</p>\n<h3>An AES Round, Step-by-Step</h3>\n<p>In this section we will take you through an entire AES round. Remember that the first round only contains the addRoundKey() step. We will be going over every step, so imagine that the first round has already passed and that we are now on the secondÂ round.</p>\n<p>Letâ€™s say we want to encrypt the following message:</p>\n<blockquote>The quick brown fox jumped over the lazyÂ dog</blockquote>\n<p>We will look only how the first block is encrypted, containing â€œThe quick brown â€. Rearranged into a 4x4 matrix, the block looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/456/1*Vun6MZNz5WVwvFY6JyflXQ.png\"></figure><p>And here it is again in hexadecimal:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/452/1*uVKDa77gjVgsfdaZNpxxzg.png\"></figure><h4>subBytes()</h4>\n<p>This is the first step in the AES round. We perform the sbox() operation on each byte in the matrix (see the Key Expansion section for details).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RmhHKWYNXTdJbP4N0gZrAg.png\"></figure><h4>shiftRows()</h4>\n<p>For this step, we rotate each row to the left a number of spaces corresponding to the row number. The first row is shifted zero spaces, the second is shifted one space, and soÂ on.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XCto0rabgzk8CjtfubHGbQ.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*S1K2igpNY813n4gV643ixw.png\"></figure><h4>mixColumns()</h4>\n<p>Now we multiply each column by the following matrix using GF(2â¸) arithmetic (gmul() and XOR instead of normal addition and multiplication):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/262/1*E0POvJgWhIcwAM7IonSyyg.png\"></figure><p>The entire transformation looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/610/1*WxfxSc5kHtxlwrJnvOkVhA.png\"></figure><p>Notice that this transformation involves many multiplications by 2 and by 3. This is where the optimizations mentioned at the end of the â€œMathematical Backgroundâ€ section come intoÂ play.</p>\n<p>In our example applying the transformation to each column looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sCWXX9VppD-b6g6GrwcsvA.png\"></figure><p>Both the shiftRows() and mixColumns() steps add <strong>diffusion</strong> to the cipher in that they allow small changes in the plaintext to affect the entirety of the ciphertext.</p>\n<h4>addRoundKey()</h4>\n<p>This is the easiest step. We XOR each byte in the block with its respective byte in the round key. Letâ€™s assume that the round key for this roundÂ is:</p>\n<blockquote>abcdefghijklmnop</blockquote>\n<p>In hexadecimal thisÂ is:</p>\n<blockquote>61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6fÂ 70</blockquote>\n<p>Keep in mind that this is a very unrealistic scenario. The round key should be pseudorandom, as well as the cipherÂ key.</p>\n<p>The result of addRoundKey() in our example looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fXQ5360UIv3GAbiYCeJYvw.png\"></figure><p>Converted back to ASCII the result of a single AES round looks likeÂ this:</p>\n<blockquote>Â€1SFÃ’Â½Â”Ã‹%ÃˆmÂ¸PÂ«Â¯</blockquote>\n<p>As you can see, the original message is already ridiculously scrambled. Magnify this by as much as fourteen times and make sure the keys are random, and you have a level of security that not even the best computers canÂ crack.</p>\n<h3>Decryption</h3>\n<p>So we have our encrypted message. How to we reverse the long and complicated process that is AES? One of the great things about <em>AES is </em>that<em> every action has itsÂ inverse.</em></p>\n<p>Decryption works like this: we generate the round keys using the same process. Then we perform the encryption algorithm in <em>reverse</em> using the inverses of the various operations.</p>\n<p>The addKeys() step is itâ€™s own inverse. XOR-ing string <em>A</em> with string <em>B</em> twice simply results in <em>A</em>. We just have to remember to use the final encryption round key as the first decryption round key, the second-to-last as the second, and soÂ on.</p>\n<p>For the mixColums() step, we apply the <em>inverse</em> of the matrix described above to all of the columns. The transformation looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zUUllEswFhKSgt4AAO3JBA.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OLYNV1RDKelE9ekkJ01o0Q.png\"></figure><p>For the shiftRows() step, we simply rotate the rows in the opposite direction. Or alternatively, rotate each row in the same direction a different number of spaces. If a byte is in row two, it will be rotated 1 space to the left during encryption, and 1 space to the right/3 spaces to the left during decryption.</p>\n<p>Finally, for the subBytes() step, we apply the <em>inverse</em> of the sbox() operation. Remember that we usually use a lookup table for sbox(). We can also use a lookup table for the inverse, which looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*m4LV9AzaTnkE9Rk44BlXfA.png\"></figure><p>One last thing: we need to remember that not all of the rounds are the same. Because we perform just addRoundKey() during the first round of encryption, we do the same for the final round of decryption. Because we omit mixColumns() from the final round of encryption, we must do so for the first round of decryption.</p>\n<p>The pseudocode for the entire decryption process looks likeÂ this:</p>\n<pre>function AESdecrypt(ciphertext, key) {<br><br>  blocks := divideIntoBlocks(ciphertext);<br>  roundKeys = getRoundKeys(key)</pre>\n<pre>  for (block in blocks) {</pre>\n<pre>    //first round<br>    addRoundKey(roundKeys[numRounds - 1], block);<br>    shiftRowsInv(block);<br>    subBytesInv(block);</pre>\n<pre>    //intermediate rounds<br>    for (8, 10 or 12 rounds) {<br>      addRoundKey(roundKeys[..], block);<br>      mixColumnsInv(block);<br>      shiftRowsInv(block);<br>      subBytesInv(block);<br>    }</pre>\n<pre>    //last round<br>    addRoundKey(roundKeys[0], block);</pre>\n<pre>}</pre>\n<pre>  plaintext := reassemble(blocks);<br>  return plaintext;</pre>\n<pre>}</pre>\n<h3>SafeHouse</h3>\n<p>Weâ€™re done! Weâ€™ve explained basically everything. With this knowledge you should be able to implement AES yourself, although we highly discourage it.</p>\n<p>We at SafeHouse believe that cybersecurity is for everyone, so weâ€™re glad to present info like this in an accessible manner. The cybersec industry is ignoring small businesses and we want to take aÂ stand.</p>\n<p>If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b6341c44edb9\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0tm9NZW_Q2--zb3SR6JIjA.png\"><figcaption>Image source: <a href=\"https://www.venafi.com/blog/what-are-best-use-cases-symmetric-vs-asymmetric-encryption\">https://www.venafi.com/blog/what-are-best-use-cases-symmetric-vs-asymmetric-encryption</a></figcaption></figure><p>Governments, militaries, banks and corporations rely on it. Itâ€™s responsible for securing most, if not all of your personal and financial data. There are special CPU instructions for it. It is the only cryptographic algorithm approved by theÂ NSA.</p>\n<p>Weâ€™re of course talking about the Advanced Encryption Standard (AES), the most commonplace and secure symmetric encryption algorithm yet developed.</p>\n<p>This will be the longest article we write for the time being ğŸ˜Š. Weâ€™re going to take a deep dive into how this algorithm works. Modern cryptographic algorithms are by no means trivial; they use concepts from advanced mathematics to achieve a high level of security. But we donâ€™t expect you to be a mathematician.</p>\n<p>While there are many articles about AES, most of them are either too technical or leave out important information. With this article we hope to strike the perfect balance between comprehensiveness and accessibility. However, we must admit that this article will require some level of comfort with math, as mathematical concepts are introduced here.</p>\n<p>It must be stated that you should not try to implement AES by yourself in a production application, or risk a <a href=\"https://en.wikipedia.org/wiki/Side-channel_attack\">side channel attack</a>. Use the many free <a href=\"https://en.wikipedia.org/wiki/Comparison_of_cryptography_libraries\">cryptographic libraries</a> that offer tested implementations of whatever algorithms youÂ need.</p>\n<h3>The Basics</h3>\n<p>First, a brief refresher on what AESÂ is.</p>\n<p>AES is not the name of the algorithm itself, but a title awarded by the National Institute of Standards and Technology (NIST) to the algorithm they deemed to be the de facto standard for encryption. The actual name of the algorithm is <em>Rijndael</em>, and it was selected by the NIST over a number of algorithms to replace the former standard, known as DES (Data Encryption Standard). Rijndael was approved by the NIST in 2001 and adopted by the US government in 2002. It remains the standard cipher used by the US government and institutions across theÂ world.</p>\n<p>AES is a <em>symmetric cipher</em>, which means that a single key is used to encrypt <em>and</em> decrypt the same data. AES can be performed with the following key sizes: <strong>128 bits, 196 bits and 256 bits</strong>. Generally, increasing the key size also increases the level of security. Rijndael works for any key size that is a multiple of 32 bits, but the NIST chose specific sizes (and other parameters) that balance performance and security.</p>\n<p>It is also a <em>block cipher</em>, meaning that the data is divided into blocks before encryption. AES divides plaintext into blocks of 16 bytes (128Â bits).</p>\n<h3>Algorithm Overview</h3>\n<p>The gist of AES is this: we arrange each block of the plaintext into a 4x4 matrix and repeatedly perform a set of operations on it. We call each iteration a <em>round</em>, and we perform <strong>10, 12 or 14 rounds</strong> depending on the key length (this is another parameter chosen byÂ NIST):</p>\n<ul>\n<li>10 rounds for a 128-bitÂ key</li>\n<li>12 rounds for a 196-bitÂ key</li>\n<li>14 rounds for a 256 bitÂ key</li>\n</ul>\n<p>For each round, we generate a <em>round key </em>from the main key using the <em>Rijndael Key Schedule</em>.</p>\n<p>There are four operations on the 4x4 matrix that we willÂ define:</p>\n<ul>\n<li>subBytes()</li>\n<li>shiftRows()</li>\n<li>mixColumns()</li>\n<li>addRoundKey()</li>\n</ul>\n<p>Not every round of operations is the same; for the first round, we only add the round key, and for the last round we omit the mixColumns() step. So the pseudocode for the AES algorithm might look something likeÂ this:</p>\n<pre>function AESencrypt(plaintext, key) {<br><br>  blocks := divideIntoBlocks(plaintext);<br>  roundKeys = getRoundKeys(key)</pre>\n<pre>  for (block in blocks) {</pre>\n<pre>    //first round<br>    addRoundKey(roundKeys[0], block);</pre>\n<pre>    //intermediate rounds<br>    for (8, 10 or 12 rounds) {<br>      subBytes(block);<br>      shiftRows(block);<br>      mixColumns(block);<br>      addRoundKey(roundKeys[..], block);<br>    }</pre>\n<pre>    //last round<br>    subBytes(block);<br>    shiftRows(block);<br>    addRoundKey(roundKeys[numRounds - 1], block);</pre>\n<pre>  }</pre>\n<pre>  ciphertext := reassemble(blocks);<br>  return ciphertext;</pre>\n<pre>}</pre>\n<h3>Mathematical Background</h3>\n<p>This section may appear rather esoteric. We told you we would explain AES in detail and we werenâ€™t lying. Luckily, we believe that the concepts in this section can be understood with only high-school level math and basic programming experience. Donâ€™t let the fancy words throw youÂ off!</p>\n<p>Letâ€™s introduce a concept in abstract algebra called a <em>Galois field</em> or <em>finite field</em>. A <em>field</em> is a set (meaning a collection of objects) with operations that act on the set and behave similarly to addition, subtraction, multiplication and division. In other words, the operations satisfy a number of properties that also hold true for addition/subtraction/multiplication/division over the rational numbers. In fact, the rational and real numbers with these four operations qualify as a field. The <em>finite</em> qualifier just means that the set has a finite number of elements.</p>\n<p>We wonâ€™t go into the specific definition of a field. Just think of it as a set of numbers where addition, subtraction, multiplication and division are redefined.</p>\n<p>AES uses a specific Galois field, which we will call <em>Rijndaelâ€™s finite field</em>, to perform many essential operations. In particular, it uses GF(2â¸) with irreducible polynomial <em>x</em>â¸ +<em> x</em>â´ + <em>x</em>Â³ + <em>x</em> + 1. Youâ€™ll understand what this means in aÂ bit.</p>\n<p>The Galois field GF(<em>pâ¿</em>), where <em>p</em> is prime and <em>n</em> is a positive integer, denotes the field with <em>pâ¿ </em>elements<em>. </em>For example, the field GF(8) (or GF(2Â³)) contains all integers from 0 to 7. An important property of Galois fields is that the elements of the field GF(<em>pâ¿</em>) are <strong>all polynomials of degree less than n with non-negative coefficients, evaluated at p</strong><em>. p</em> is called the <em>characteristic</em> of theÂ field.</p>\n<p>Letâ€™s look at GF(8), or GF(2Â³), again. GF(2Â³) contains {0, 1, 2, 3, 4, 5, 6, 7}, which can be equivalently represented as {0, 1, 2, 2 + 1, 2Â², 2Â²+ 1, 2Â²+ 2, 2Â²+ 2 + 1}, or {0, 1, <em>x</em>, <em>x</em>+ 1, <em>x</em>Â², <em>x</em>Â² + 1, <em>x</em>Â² + <em>x</em>, <em>x</em>Â² + <em>x</em>+ 1} where <em>x</em> =Â 2.</p>\n<p>With this notation out of the way, we can now explain how addition/subtraction/multiplication/division works with GaloisÂ fields.</p>\n<h4><strong>Addition/Subtraction</strong></h4>\n<p>Suppose we want to add elements <em>a</em> and <em>b</em> of GF(<em>pâ¿</em>). First, convert them to their polynomial forms, that is, write them as sums of powers of <em>p</em>. Then we add the polynomials together, but with a caveat: for each coefficient <em>a_k</em> in <em>a(p)</em>, <em>b_k</em> in <em>b(p)</em>, the resulting coefficient <em>c_k </em>is equal to <em>a_k</em> + <em>b_k</em> mod <em>p</em>. For subtraction, the formula is <em>c_k</em> = <em>a_k</em>â€Šâ€”â€Š<em>b_k</em> modÂ <em>p</em>.</p>\n<p>We apologize for Mediumâ€™s lack of support for mathematical expressions. Here are the formulas again inÂ LaTeX:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/544/1*b32ra3kUxYZx0PAk-fBF0g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/584/1*-XPMYNDqSAghS8q8jizwpA.png\"></figure><p>â€œmodâ€ of course stands for modulo, which in most programming languages is written as â€œ%â€. Letâ€™s look at anÂ example:</p>\n<p>74 + 26 in GF(3â´) = (2 * 3Â³ + 2 * 3Â² + 2 * 1) + (2 * 3Â² + 2 * 3 + 2 *Â 1)</p>\n<p>= (2 * 3Â³ + 4 * 3Â² + 2 * 3 + 4 * 1) = (2 * 3Â³ + 3Â² + 6 + 1) =Â <strong>70</strong></p>\n<p>Notice that 4 * 3Â² became 3Â² and 4 * 1 became 1 because of the modulo operation on the coefficients.</p>\n<p>The Rijndael field GF(2â¸), as well as all fields with characteristic 2, share a property that makes them well suited for computers: <strong>addition and subtraction are equivalent to the bitwise exclusive or (XOR/âŠ•) operation.</strong> This works because <strong>each term in the polynomial represents a bit.</strong> Here is another example to demonstrate thisÂ fact:</p>\n<p>15 + 12 in GF(2â´) = (2Â³ + 2Â² + 2 + 1) + (2Â³ +Â 2Â²)</p>\n<p>= (2 * 2Â³ + 2 * 2Â² + 2 + 1) = (2 + 1) =Â <strong>3</strong></p>\n<p>15 âŠ• 12 = 0b1111 âŠ• 0b1100 = 0b0011 =Â <strong>3</strong></p>\n<p>Addition in Galois fields is often referred to as â€œcarryless addition.â€ We add each set of digits independently modulo <em>p</em>. Note that in the example above, the first set of digits adds to 2 mod 2 = 0, while the second set adds to 7 mod 2 =Â 3.</p>\n<h4><strong>Multiplication</strong></h4>\n<p>In order to multiply two polynomials <em>a(p)</em> and <em>b(p)</em> in GF(<em>pâ¿</em>), we need to chose a third polynomial <em>m(p) </em>that <em>cannot be factored</em> and has a degree of at least <em>n</em>. We call m(p) the irreducible polynomial.</p>\n<p>To multiply <em>a(p)</em> and <em>b(p) in </em>GF(<em>pâ¿</em>) we perform the following steps:</p>\n<ul>\n<li>Multiply <em>a(p)</em> and <em>b(p) </em>likeÂ normal</li>\n<li>Reduce the coefficients of the resulting polynomial moduloÂ p.</li>\n<li>Reduce the entire polynomial mod <em>m(p). </em>This is so our final answer stays less than<em>Â pâ¿.</em>\n</li>\n</ul>\n<p>The final step can be performed using polynomial long division. <strong>However, this is no ordinary division<em>.</em> Every arithmetic operation we perform during the process must be the finite fieldâ€™s version.</strong> In the case of GF(2â¸), every time we perform â€œsubtractionâ€, we actually perform the XOR operation. Representing the polynomials as binary strings will be helpful for thisÂ step.</p>\n<p>Letâ€™s perform 193 * 56 in GF(2â¸) and with <em>m(p)</em> = <em>x</em>â¸ +<em> x</em>â´ + <em>x</em>Â³ + <em>x</em> + 1 (Rijndaelâ€™s field):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*rc1od0FZUReYTN0q6MJAow.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*QdgLMbTc2cpGQEC3UXjZfw.png\"></figure><p>If multiplication in finite fields seems complicated, donâ€™t worry! With Rijndaelâ€™s field, the multiplication algorithm can be greatly optimized beyond what is described above. Below is a pseudocode implementation:</p>\n<pre>function gmul(a : byte, b : byte) {</pre>\n<pre>  p : byte = 0x00;<br><br>  for (8 rounds) {</pre>\n<pre>    //if low bit of b is set<br>    if ((b &amp; 1) != 0) {<br>      p = p âŠ• a;<br>    }<br><br>    //true if the high bit of a is set<br>    h : bool = (a &amp; 0x80) != 0;</pre>\n<pre>    a = a &lt;&lt; 1; //shift left<br><br>    if (h) {<br>      a = a âŠ• 0x1B; //value of the polynomial m(p) (0x11B) with the high bit removed<br>    }</pre>\n<pre>    b = b &gt;&gt; 1; //right shift</pre>\n<pre>   return p;</pre>\n<pre>  }  <br>}</pre>\n<h4>The Multiplicative Inverse/Division</h4>\n<p>The multiplicative inverse of a polynomial a(p) is the polynomial b(p) such that a(p) * b(p) mod m(p) = 1. Multiplicative inverses can be found by applying the inverse of the algorithm above. Division is simply a matter of multiplying the first operand by the multiplicative inverse of theÂ second.</p>\n<h4><strong>Whatâ€™s theÂ point?</strong></h4>\n<p>Why does AES borrow concepts from finite field theory. The main reason is performance. Remember that â€œadditionâ€ in GF(2â¸) is the same as the XOR operation. Also consider that there is no need to worry about overflow/underflow, because the inputs and outputs of the operations are restricted to the numbersÂ 0â€“255.</p>\n<p>Multiplication is less complicated than it looks. To put things in perspective, consider how computers perform normal multiplication at the lowest level: through repeated bit shifts and additions (of course, we donâ€™t have special circuitry to perform GF(2â¸) arithmetic). Finally, multiplication by 2 and 3 is very easy to optimize. This will become important later.</p>\n<pre>//multiply by 2 in GF(2^8)<br>function gmul2(a : byte) {</pre>\n<pre>  h : byte = a &amp; 0x80; //high bit</pre>\n<pre>  b : byte = a &lt;&lt; 1;</pre>\n<pre>  if (h == 0x80) b = b âŠ• 0x1b;</pre>\n<pre>  return b; </pre>\n<pre>}</pre>\n<pre>//multiply by 3 in GF(2^8)<br>function gmul3(a : byte) {</pre>\n<pre>  return a âŠ• gmul2(a);</pre>\n<pre>}</pre>\n<h3>Key Expansion</h3>\n<p>Weâ€™re done with background! Now itâ€™s time to look into the nitty-gritty of what AES actuallyÂ does.</p>\n<p>Before any encryption takes place, separate 128-bit keys must be generated for each round. Rijndael uses a specific algorithm to generate roundÂ keys.</p>\n<p>The Rijndael key schedule performs a number of operations:</p>\n<p><strong>rotate():</strong> rotates a 32-bit (4 byte) word 8 bits to the left. As an example: rotate(0xab157c9e) = 0x157c9eab.</p>\n<p><strong>rcon():</strong> exponentiates (repeatedly multiplies) 2 to a specified value in Rijndaelâ€™s finite field. This operation can be described by the pseudocode below. However, we will only need to use a maximum of 11 rcon() values, so a lookup table is sufficient.</p>\n<pre>function rcon(value : unsigned int) {</pre>\n<pre>  c : byte = 1;<br><br>  if (value == 0) return 0;<br>  while (value != 1) {<br>    c = gmul(c, 2);<br>    value--;<br>  }</pre>\n<pre>  return c;</pre>\n<pre>}</pre>\n<p>We have not yet explained how exponentiation works for finite fields. In short, it works very similarly to normal mathematics. We encourage curious readers to do their own research if they want to learnÂ more.</p>\n<p><strong>sbox():</strong> another operation in Rijndaelâ€™s field, usually implemented with the following lookupÂ table:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jS3HSAr5mIotBFA0EXgW1A.png\"></figure><p>Mathematically, sbox() is a two part operation. First, we take the multiplicative inverse of the input. The result is represented as an eight-element vector (one for each bit) and undergoes the following transformation:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*-l0Y4dkfLh-KEpUlNuoy_Q.png\"></figure><p>The entire process is performed with Rijndaelâ€™s finite field arithmetic. So at the end, for example, the byte 0b11000110 is not added, but <strong>XORâ€™ed</strong> with the matrix-vector product. This transformation is more succinctly represented as a series of XORs and left bitwise rotations likeÂ so:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*hn53zg152FwaSqwu6ECvyQ.png\"></figure><p>The sbox() operation heavily contributes to the security of AES as a whole. It is resistant to <strong>linear cryptoanalysis</strong> in that it is hard to approximate with a linear transformation. It is also resistant to <strong>differential cryptoanalysis</strong> in that there seems to be no correlation between how the input changes and how the output changes. Finally, sbox() is special in that there are no <strong>fixed points</strong>, i.e. there are no situations where the input equals theÂ output.</p>\n<p>The key expansion algorithm works mainly on 32-bit words instead of bytes. For the future, we will define <strong>subWord() </strong>as the application of sbox() on each byte of aÂ word.</p>\n<h4>The Key Expansion Algorithm</h4>\n<p>Onto the actual key-generation algorithm. Letâ€™s define some constants before we take a look at theÂ steps:</p>\n<ul>\n<li>Let K[0] thru K[N-1] represent the 32-bit words of the originalÂ key.</li>\n<li>Let N equal the length of the original key in 32-bit words <strong>(4, 6, or 8 for a 128, 192 or 256-bit key respectively).</strong>\n</li>\n<li>Let R equal the number of rounds <strong>(10, 12, or 15 for a 128, 192 or 256-bit key respectively).</strong>\n</li>\n<li>Let W[0] thru W[4R-1] represent the 32-bit words comprising all of the round keys. Letâ€™s call this the expandedÂ key.</li>\n</ul>\n<p>The key expansion algorithm iterates through all of the 32-bit words W[0] thru W[4R-1]. When we want a specific round key, we combine the four words (128 bits) from of the expanded key corresponding to that round. For example, the Round 3 Key comprises of W[8] thruÂ W[11].</p>\n<p>The algorithm goes likeÂ this:</p>\n<pre>for (i from 0 to 4R - 1) {</pre>\n<pre>  //The first words (W[0] thru W[N-1]) are equal to the words of the original key.<br>  //For a 128-bit key, this means that the first round key is equal to the original key.<br>  if (0 &lt; i &lt; N) W[i] = K[i];</pre>\n<pre>  //Perform operations on the last word of each N-length cycle before XOR-ing.<br>  else if (i &gt;= N and i == 0 mod N)<br>    W[i] = W[i-N] <strong>âŠ• </strong>subWord(rotate(W[i-1])) <strong>âŠ• </strong>rcon(i/N);</pre>\n<pre>  //For a 256-bit key length only.<br>  else if (i &gt;= N and N == 8 and i == 4 mod N)<br>    W[i] = W[i-N] <strong>âŠ• </strong>subWord(W[i-1])<strong>;</strong></pre>\n<pre>  //Typical case<br>  else W[i] = W[i-N] <strong>âŠ• </strong>W[i-1];</pre>\n<pre>}</pre>\n<p>The gist of the algorithm is this: generally, each word is the previous word XORâ€™ed with the word N places behind it. But every N words, we perform various GF(2â¸) operations on the word N places behind before the XOR-ing takesÂ place.</p>\n<h3>An AES Round, Step-by-Step</h3>\n<p>In this section we will take you through an entire AES round. Remember that the first round only contains the addRoundKey() step. We will be going over every step, so imagine that the first round has already passed and that we are now on the secondÂ round.</p>\n<p>Letâ€™s say we want to encrypt the following message:</p>\n<blockquote>The quick brown fox jumped over the lazyÂ dog</blockquote>\n<p>We will look only how the first block is encrypted, containing â€œThe quick brown â€. Rearranged into a 4x4 matrix, the block looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/456/1*Vun6MZNz5WVwvFY6JyflXQ.png\"></figure><p>And here it is again in hexadecimal:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/452/1*uVKDa77gjVgsfdaZNpxxzg.png\"></figure><h4>subBytes()</h4>\n<p>This is the first step in the AES round. We perform the sbox() operation on each byte in the matrix (see the Key Expansion section for details).</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*RmhHKWYNXTdJbP4N0gZrAg.png\"></figure><h4>shiftRows()</h4>\n<p>For this step, we rotate each row to the left a number of spaces corresponding to the row number. The first row is shifted zero spaces, the second is shifted one space, and soÂ on.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*XCto0rabgzk8CjtfubHGbQ.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*S1K2igpNY813n4gV643ixw.png\"></figure><h4>mixColumns()</h4>\n<p>Now we multiply each column by the following matrix using GF(2â¸) arithmetic (gmul() and XOR instead of normal addition and multiplication):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/262/1*E0POvJgWhIcwAM7IonSyyg.png\"></figure><p>The entire transformation looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/610/1*WxfxSc5kHtxlwrJnvOkVhA.png\"></figure><p>Notice that this transformation involves many multiplications by 2 and by 3. This is where the optimizations mentioned at the end of the â€œMathematical Backgroundâ€ section come intoÂ play.</p>\n<p>In our example applying the transformation to each column looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sCWXX9VppD-b6g6GrwcsvA.png\"></figure><p>Both the shiftRows() and mixColumns() steps add <strong>diffusion</strong> to the cipher in that they allow small changes in the plaintext to affect the entirety of the ciphertext.</p>\n<h4>addRoundKey()</h4>\n<p>This is the easiest step. We XOR each byte in the block with its respective byte in the round key. Letâ€™s assume that the round key for this roundÂ is:</p>\n<blockquote>abcdefghijklmnop</blockquote>\n<p>In hexadecimal thisÂ is:</p>\n<blockquote>61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6fÂ 70</blockquote>\n<p>Keep in mind that this is a very unrealistic scenario. The round key should be pseudorandom, as well as the cipherÂ key.</p>\n<p>The result of addRoundKey() in our example looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*fXQ5360UIv3GAbiYCeJYvw.png\"></figure><p>Converted back to ASCII the result of a single AES round looks likeÂ this:</p>\n<blockquote>Â€1SFÃ’Â½Â”Ã‹%ÃˆmÂ¸PÂ«Â¯</blockquote>\n<p>As you can see, the original message is already ridiculously scrambled. Magnify this by as much as fourteen times and make sure the keys are random, and you have a level of security that not even the best computers canÂ crack.</p>\n<h3>Decryption</h3>\n<p>So we have our encrypted message. How to we reverse the long and complicated process that is AES? One of the great things about <em>AES is </em>that<em> every action has itsÂ inverse.</em></p>\n<p>Decryption works like this: we generate the round keys using the same process. Then we perform the encryption algorithm in <em>reverse</em> using the inverses of the various operations.</p>\n<p>The addKeys() step is itâ€™s own inverse. XOR-ing string <em>A</em> with string <em>B</em> twice simply results in <em>A</em>. We just have to remember to use the final encryption round key as the first decryption round key, the second-to-last as the second, and soÂ on.</p>\n<p>For the mixColums() step, we apply the <em>inverse</em> of the matrix described above to all of the columns. The transformation looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zUUllEswFhKSgt4AAO3JBA.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OLYNV1RDKelE9ekkJ01o0Q.png\"></figure><p>For the shiftRows() step, we simply rotate the rows in the opposite direction. Or alternatively, rotate each row in the same direction a different number of spaces. If a byte is in row two, it will be rotated 1 space to the left during encryption, and 1 space to the right/3 spaces to the left during decryption.</p>\n<p>Finally, for the subBytes() step, we apply the <em>inverse</em> of the sbox() operation. Remember that we usually use a lookup table for sbox(). We can also use a lookup table for the inverse, which looks likeÂ this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*m4LV9AzaTnkE9Rk44BlXfA.png\"></figure><p>One last thing: we need to remember that not all of the rounds are the same. Because we perform just addRoundKey() during the first round of encryption, we do the same for the final round of decryption. Because we omit mixColumns() from the final round of encryption, we must do so for the first round of decryption.</p>\n<p>The pseudocode for the entire decryption process looks likeÂ this:</p>\n<pre>function AESdecrypt(ciphertext, key) {<br><br>  blocks := divideIntoBlocks(ciphertext);<br>  roundKeys = getRoundKeys(key)</pre>\n<pre>  for (block in blocks) {</pre>\n<pre>    //first round<br>    addRoundKey(roundKeys[numRounds - 1], block);<br>    shiftRowsInv(block);<br>    subBytesInv(block);</pre>\n<pre>    //intermediate rounds<br>    for (8, 10 or 12 rounds) {<br>      addRoundKey(roundKeys[..], block);<br>      mixColumnsInv(block);<br>      shiftRowsInv(block);<br>      subBytesInv(block);<br>    }</pre>\n<pre>    //last round<br>    addRoundKey(roundKeys[0], block);</pre>\n<pre>}</pre>\n<pre>  plaintext := reassemble(blocks);<br>  return plaintext;</pre>\n<pre>}</pre>\n<h3>SafeHouse</h3>\n<p>Weâ€™re done! Weâ€™ve explained basically everything. With this knowledge you should be able to implement AES yourself, although we highly discourage it.</p>\n<p>We at SafeHouse believe that cybersecurity is for everyone, so weâ€™re glad to present info like this in an accessible manner. The cybersec industry is ignoring small businesses and we want to take aÂ stand.</p>\n<p>If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b6341c44edb9\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["cybersecurity","privacy","programming","technology","computer-science"]},{"title":"How TLS Protects Your Web Activity","pubDate":"2021-07-02 00:56:22","link":"https://devsafehouse.medium.com/how-tls-protects-your-web-activity-7a9558d98e5d?source=rss-2264614a31c6------2","guid":"https://medium.com/p/7a9558d98e5d","author":"SafeHouse","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*ZEwXotDGMjL_xB2FH58oQw.jpeg","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZEwXotDGMjL_xB2FH58oQw.jpeg\"><figcaption>Image source: <a href=\"https://securedcommunications.com/download--secured-communications.html\">https://securedcommunications.com/download--secured-communications.html</a></figcaption></figure><p>In our <a href=\"https://devsafehouse.medium.com/\">many articles about how the internet works</a>, we left out an important detail. Many common internet-facing applications secure data before itâ€™s sent out into the world. But how? With an ingenious protocol known asÂ TLS.</p>\n<h3>What isÂ TLS?</h3>\n<p>In the olden days of the internet, communication was completely unencrypted. This meant that eavesdroppers could potentially see all of the data sent over the internet. People had to be very careful when sending sensitive information.</p>\n<p>This problem was recognized as early as 1994, so the SSL (Secure Socket Layer) protocol was developed. SSL encrypts data at one endpoint and decrypts it at the other, such that data passed between computers was completely unintelligible. Keep in mind that this protocol does not protect data sitting on your computer (â€œat restâ€); it only protects data in transit when two computers connect to eachÂ other.</p>\n<p>TLS (Transport Layer Security) is a similar protocol to SSL and shares the same purpose. The first version was developed in 1999 and based on SSL 3.0. When SSL 3.0 was found to be insecure, it was completely replaced by TLS. TLS is used for web browsing, but can be used for a variety of services. Today, TLS 1.3 is the latest version of TLS and earlier versions should beÂ avoided.</p>\n<p>You may have noticed when browsing the web that some URLs start with â€œhttpâ€ and others with â€œhttps.â€ HTTP stands for Hypertext Transfer Protocol, and it is the protocol that retrieves HTML and other media to be displayed by your web browser. HTTPS is a version of HTTP with integrated TLS/SSL. In other words, accessing an â€œhttpsâ€ website means that your communications with the server are encrypted. Itâ€™s recommended that every website switch to HTTPS by purchasing an SSL certificate.</p>\n<h3>How Does TLSÂ Work</h3>\n<p>The first question one might ask about encrypted communication is â€œhow do both parties know how to decrypt the messages? Surely they canâ€™t just send the key over the web!â€ In fact, they can, and we will explain how step byÂ step.</p>\n<p>Suppose you are a web browser and you want to connect to a websiteâ€™s host. The browser will conduct a conversation with the server to establish a secure channel. This conversation is called the TLS handshake.</p>\n<p><strong>Step 1: The client will send a â€œhelloâ€ message to the server, containing the TLS/SSL versions it is using, a list of supported cipher suites, and string of random bytes (called the <em>clientÂ random</em>).</strong></p>\n<p>What is meant by â€œcipher suite?â€ Weâ€™ll get to that. First of all, a cipher is simply an algorithm to encrypt a message. For example, replacing each letter in a message with a number is a type of cipher. But the ones used by TLS are far more complicated and impossible to break by humans or computers alike.</p>\n<p>A cipher can be <em>symmetric</em> or <em>asymmetric</em>. A symmetric cipher is one in which a single key is used to encrypt and decrypt the message. They are most useful when only you want to see the contents of the message, since sharing the key is a security risk. The most common symmetric cipher used by TLS is <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">AES (Advanced Encryption Standard)</a>.</p>\n<p>Asymmetric ciphers require separate keys to encrypt and decrypt the message, and they are the most important component when establishing a secure session. What makes these algorithms work is that an attacker cannot decipher the message with the encryption key; he <em>must</em> have the decryption key. Therefore, the encryption key, also called the Public Key, can be freely traded between parties without posing a security risk, as long as the decryption key (a.k.a. the Private Key) is not revealed. The principle asymmetric ciphers employed by TLS are <a href=\"https://en.wikipedia.org/wiki/RSA_(cryptosystem)\">RSA (Rivestâ€“Shamirâ€“Adleman)</a> and DHE (<a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">Diffieâ€“Hellman</a>).</p>\n<p>Now we can define â€œcipher suite.â€ A cipher suite contains:</p>\n<ol>\n<li>A symmetric encryption algorithm (such asÂ AES)</li>\n<li>An asymmetric encryption algorithm (such asÂ RSA)</li>\n<li>A Message Authentication Code (MAC), used to authenticate messages</li>\n</ol>\n<p><strong>Step 2: The server generates a public/private key pair and responds to the client with: the cipher suite it wants to use, the TLS version it wants to use, a digital certificate, the public key, and another string of random bytes (called the <em>serverÂ random</em>).</strong></p>\n<p>The digital certificate is supplied by the serverâ€™s domain name provider. The client will check with them and ensure that the server is the actual owner of theÂ domain.</p>\n<p>After this message is sent, the client and server will use the highest TLS version and the most secure cipher suite available toÂ both.</p>\n<p><strong>Step 3: The client generates another string of random bytes (called the <em>pre-master secret</em>), encrypts it with the serverâ€™s public key, and sends the result to theÂ server.</strong></p>\n<p><strong>Step 4: The server decrypts the message sent by the client with its private key. Now both the server and the client have the unencrypted pre-master secret.</strong></p>\n<p><strong>Step 5: The server and the client use the pre-master secret, the client random and the server random to generate another key, called the <em>session key</em>. They should both generate the sameÂ key.</strong></p>\n<p>Keep in mind that the session key is different than the serverâ€™s public/private keys. The former is a key for a symmetric algorithm such as AES, whereas the public/private keys were either RSA orÂ DHE.</p>\n<p><strong>Step 6: The server and client will exchanged messages encrypted with the session key to ensure that the handshake worked.</strong></p>\n<p><strong>Step 7: If the handshake was successful, the client and server will use the session key for the remainder of session. The MAC is used in conjunction with the session key to authenticate messages.</strong></p>\n<p>Once a secure connection is established, there is no need to keep the private key, public key, or pre-master secret.</p>\n<p>And thatâ€™s it! Except for one small detail: this is how TLS works with RSA. With DHE, there are a coupleÂ changes:</p>\n<ol>\n<li>Along with the public key, the server sends a message encrypted with the private key to prove that the two keys are indeed pairs. The message contains a string known as the DH parameter.</li>\n<li>Instead of the client generating the pre-master secret randomly, both the server and client use the DH parameter to generateÂ it.</li>\n</ol>\n<h3>Summarizing What You JustÂ Read</h3>\n<p>This was a lot to take in. If thereâ€™s anything you derive from the preceding information itâ€™sÂ this:</p>\n<p><strong>We use an asymmetric encryption algorithm to exchange information that generates a symmetric encryption key.</strong></p>\n<p>The real genius lies in how the encryption algorithms work, so if youâ€™re a sucker for math we highly recommend you checking them out. We will probably explain how they work in future articles.</p>\n<p>SafeHouse will use the techniques shown in this article for its own software. If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7a9558d98e5d\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ZEwXotDGMjL_xB2FH58oQw.jpeg\"><figcaption>Image source: <a href=\"https://securedcommunications.com/download--secured-communications.html\">https://securedcommunications.com/download--secured-communications.html</a></figcaption></figure><p>In our <a href=\"https://devsafehouse.medium.com/\">many articles about how the internet works</a>, we left out an important detail. Many common internet-facing applications secure data before itâ€™s sent out into the world. But how? With an ingenious protocol known asÂ TLS.</p>\n<h3>What isÂ TLS?</h3>\n<p>In the olden days of the internet, communication was completely unencrypted. This meant that eavesdroppers could potentially see all of the data sent over the internet. People had to be very careful when sending sensitive information.</p>\n<p>This problem was recognized as early as 1994, so the SSL (Secure Socket Layer) protocol was developed. SSL encrypts data at one endpoint and decrypts it at the other, such that data passed between computers was completely unintelligible. Keep in mind that this protocol does not protect data sitting on your computer (â€œat restâ€); it only protects data in transit when two computers connect to eachÂ other.</p>\n<p>TLS (Transport Layer Security) is a similar protocol to SSL and shares the same purpose. The first version was developed in 1999 and based on SSL 3.0. When SSL 3.0 was found to be insecure, it was completely replaced by TLS. TLS is used for web browsing, but can be used for a variety of services. Today, TLS 1.3 is the latest version of TLS and earlier versions should beÂ avoided.</p>\n<p>You may have noticed when browsing the web that some URLs start with â€œhttpâ€ and others with â€œhttps.â€ HTTP stands for Hypertext Transfer Protocol, and it is the protocol that retrieves HTML and other media to be displayed by your web browser. HTTPS is a version of HTTP with integrated TLS/SSL. In other words, accessing an â€œhttpsâ€ website means that your communications with the server are encrypted. Itâ€™s recommended that every website switch to HTTPS by purchasing an SSL certificate.</p>\n<h3>How Does TLSÂ Work</h3>\n<p>The first question one might ask about encrypted communication is â€œhow do both parties know how to decrypt the messages? Surely they canâ€™t just send the key over the web!â€ In fact, they can, and we will explain how step byÂ step.</p>\n<p>Suppose you are a web browser and you want to connect to a websiteâ€™s host. The browser will conduct a conversation with the server to establish a secure channel. This conversation is called the TLS handshake.</p>\n<p><strong>Step 1: The client will send a â€œhelloâ€ message to the server, containing the TLS/SSL versions it is using, a list of supported cipher suites, and string of random bytes (called the <em>clientÂ random</em>).</strong></p>\n<p>What is meant by â€œcipher suite?â€ Weâ€™ll get to that. First of all, a cipher is simply an algorithm to encrypt a message. For example, replacing each letter in a message with a number is a type of cipher. But the ones used by TLS are far more complicated and impossible to break by humans or computers alike.</p>\n<p>A cipher can be <em>symmetric</em> or <em>asymmetric</em>. A symmetric cipher is one in which a single key is used to encrypt and decrypt the message. They are most useful when only you want to see the contents of the message, since sharing the key is a security risk. The most common symmetric cipher used by TLS is <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">AES (Advanced Encryption Standard)</a>.</p>\n<p>Asymmetric ciphers require separate keys to encrypt and decrypt the message, and they are the most important component when establishing a secure session. What makes these algorithms work is that an attacker cannot decipher the message with the encryption key; he <em>must</em> have the decryption key. Therefore, the encryption key, also called the Public Key, can be freely traded between parties without posing a security risk, as long as the decryption key (a.k.a. the Private Key) is not revealed. The principle asymmetric ciphers employed by TLS are <a href=\"https://en.wikipedia.org/wiki/RSA_(cryptosystem)\">RSA (Rivestâ€“Shamirâ€“Adleman)</a> and DHE (<a href=\"https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange\">Diffieâ€“Hellman</a>).</p>\n<p>Now we can define â€œcipher suite.â€ A cipher suite contains:</p>\n<ol>\n<li>A symmetric encryption algorithm (such asÂ AES)</li>\n<li>An asymmetric encryption algorithm (such asÂ RSA)</li>\n<li>A Message Authentication Code (MAC), used to authenticate messages</li>\n</ol>\n<p><strong>Step 2: The server generates a public/private key pair and responds to the client with: the cipher suite it wants to use, the TLS version it wants to use, a digital certificate, the public key, and another string of random bytes (called the <em>serverÂ random</em>).</strong></p>\n<p>The digital certificate is supplied by the serverâ€™s domain name provider. The client will check with them and ensure that the server is the actual owner of theÂ domain.</p>\n<p>After this message is sent, the client and server will use the highest TLS version and the most secure cipher suite available toÂ both.</p>\n<p><strong>Step 3: The client generates another string of random bytes (called the <em>pre-master secret</em>), encrypts it with the serverâ€™s public key, and sends the result to theÂ server.</strong></p>\n<p><strong>Step 4: The server decrypts the message sent by the client with its private key. Now both the server and the client have the unencrypted pre-master secret.</strong></p>\n<p><strong>Step 5: The server and the client use the pre-master secret, the client random and the server random to generate another key, called the <em>session key</em>. They should both generate the sameÂ key.</strong></p>\n<p>Keep in mind that the session key is different than the serverâ€™s public/private keys. The former is a key for a symmetric algorithm such as AES, whereas the public/private keys were either RSA orÂ DHE.</p>\n<p><strong>Step 6: The server and client will exchanged messages encrypted with the session key to ensure that the handshake worked.</strong></p>\n<p><strong>Step 7: If the handshake was successful, the client and server will use the session key for the remainder of session. The MAC is used in conjunction with the session key to authenticate messages.</strong></p>\n<p>Once a secure connection is established, there is no need to keep the private key, public key, or pre-master secret.</p>\n<p>And thatâ€™s it! Except for one small detail: this is how TLS works with RSA. With DHE, there are a coupleÂ changes:</p>\n<ol>\n<li>Along with the public key, the server sends a message encrypted with the private key to prove that the two keys are indeed pairs. The message contains a string known as the DH parameter.</li>\n<li>Instead of the client generating the pre-master secret randomly, both the server and client use the DH parameter to generateÂ it.</li>\n</ol>\n<h3>Summarizing What You JustÂ Read</h3>\n<p>This was a lot to take in. If thereâ€™s anything you derive from the preceding information itâ€™sÂ this:</p>\n<p><strong>We use an asymmetric encryption algorithm to exchange information that generates a symmetric encryption key.</strong></p>\n<p>The real genius lies in how the encryption algorithms work, so if youâ€™re a sucker for math we highly recommend you checking them out. We will probably explain how they work in future articles.</p>\n<p>SafeHouse will use the techniques shown in this article for its own software. If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=7a9558d98e5d\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["computer-science","cybersecurity","technology","internet","encryption"]},{"title":"Demystifying Ethernet and Fiber Optics","pubDate":"2021-06-25 19:10:25","link":"https://devsafehouse.medium.com/demystifying-ethernet-and-fiber-optics-342c3744f40b?source=rss-2264614a31c6------2","guid":"https://medium.com/p/342c3744f40b","author":"SafeHouse","thumbnail":"https://cdn-images-1.medium.com/max/1024/1*IvET1GBz1yvK9MBNm3OOlg.jpeg","description":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvET1GBz1yvK9MBNm3OOlg.jpeg\"><figcaption>Light signals illuminating the ends of fiber opticÂ wires</figcaption></figure><p>In our <a href=\"https://devsafehouse.medium.com/tcp-vs-udp-whats-the-difference-8ef9616fc14a\">last article</a>, we talked about TCP and UDP, the protocols that handle the delivery and verification of data sent over the internet. In this article we will shift our focus to hardware: how is data passed betweenÂ devices?</p>\n<p><em>Ethernet</em> and <em>Fiber Optics</em> are probably terms youâ€™ve heard before, maybe in advertisements or skimming through E-Bay. You may already know that they have something to do with wired communication. But what are they really, and why is Fiber Optics all the rage now? This article will help you understand!</p>\n<h3>What is Ethernet?</h3>\n<p>Ethernet is a protocol for wired communications. It is most commonly used for Local Area Networks (LAN), i.e. small networks usually controlled by switches. However, the Ethernet protocol can be used for MAN (Metropolitan Area Networks) and WAN (Wide Area Networks) asÂ well.</p>\n<p>First developed by Xerox in 1973, it was standardized in 1980 by the Institute of Electrical and Electronic Engineers (IEEE) and has since gone through many revisions to improve bitrate and power usage. The standard for Ethernet and other wired communication infrastructure (IEEE 802) specify both the type of wire and how data is sent throughÂ it.</p>\n<p>An <em>ethernet cable</em> is a telecommunications cable that meets the IEEE specification. Any cable you use to connect an internet-facing device to a switch or router is most likely an EthernetÂ cable.</p>\n<h3>Old Network CableÂ Types</h3>\n<p>The Ethernet standard has gone through many changes to improve bitrate and power usage. Most significant of these is the type of cable used to transfer theÂ data.</p>\n<h4>Coaxial Cables</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ma8W_Qwet4hjy5KfxSiQ1g.jpeg\"><figcaption>Layers of a coaxial cable (<a href=\"https://frida-cable.en.made-in-china.com/product/zegEUlaKHDVZ/China-Coaxial-Cable-RG58-RG174-RG213-.html\">imageÂ source</a>)</figcaption></figure><p>The first telecommunications cables were known as <em>coaxial</em> (or coax) cables. Coax cables were first used in 1858 but were first patented in 1880 by British mathematician Oliver Heaviside. They were originally used for telegraph, radio and television communications, and 1980 to the 90â€™s were the Ethernet standard for 10Mb/s communication. They came in two varieties: thinnet (10BASE2 standard) or thicknet (10BASE5).</p>\n<p>Coax cables consisted of a conductive wire (usually copper) surrounded by a dielectric layer and a metallic shield, all covered in an insulating jacket. The key benefit of coaxial cables was that the electrical field was contained within the metal shield. However, this is only true for ideal, infinitely smooth coax cables. In the real world, noise and signal leakage was a problem, and the cables were already very stiff. If internet speeds were to improve, another solution wasÂ needed.</p>\n<h4>Twisted PairÂ Cables</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*VoME_LXxAtzz4TiDHwvaqA.jpeg\"><figcaption>Inside a twisted pair cable (<a href=\"https://www.markertek.com/product/bl-1583a/belden-1583a-cat-5e-twisted-pair-cable-per-foot\">imageÂ source</a>)</figcaption></figure><p>Starting in the â€˜90â€™s, the <em>twisted pair </em>design<em> </em>became the most performant Ethernet standard<em>. </em>Twisted pair cables could achieve bitrates from 10Mb/s to 10Gb/s. The 10Mb/s variety was called 10BASE-T or Category 3. The 100Mb/s standards were known as 100BASE-TX, Cat5, and Cat5e. Finally, the 10Gb/s variety was called 10GBASE-T.</p>\n<p>As the name suggests, a twisted pair cable consists of four pairs of copper wires, each twisted in a helix shape. Twisted pair cables can be shielded (STP) or unshielded (UTP). In the shielded version, each pair is given its own insulating jacket, whereas the same is not true for the unshielded version. However, the unshielded version may have a separator or drain wire to achieve the same level of protection. In general, the unshielded variety is more common for costÂ reasons.</p>\n<p>The twisted pair design dramatically increased internet speeds and reduced the problem associated with coax cables. But twisted pair cables are not the most performant cable outÂ there.</p>\n<h3>Fiber Optics</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5bvgeYAgMG1VeZJyyreaOg.jpeg\"><figcaption>Inside a fiber optic cable (<a href=\"https://sikora.net/en/sikora-quality-assurance-at-the-production-of-optical-fiber-cables/\">imageÂ source</a>)</figcaption></figure><p>Time for the mainÂ event!</p>\n<p>Currently, the Ethernet standards with the highest bitrates use fiber optic cables. The standards go up to 100 Gb/s, but the best fiber optic cables support bitrates on the order of terabits. Unlike the previous types of cables, fiber optics is most commonly used for intercontinental, WAN communication.</p>\n<p>What is most interesting about these cables, though, is their design. Instead of electrical signals passing through copper wires, infrared light is passed through threads of glass or plastic. This design is well-suited for long-distance communication because the signals are immune to electromagnetic interference and they taper off lessÂ quickly.</p>\n<p>Fiber optics is nothing new. The first optical fiber was developed in the â€™70s and its use as a communication medium was investigated in the 80s and 90s. It only took off in the 2000â€™s when optical fiber became commercially available. Since then, fiber optic cables have become an integral part of our global telecommunications system. ISPs (Verizon, AT&amp;T, Optimum, etc.) have also invested in providing fiber optic internet to theÂ home.</p>\n<h4>SafeHouse</h4>\n<p>We are currently developing tools to protect your network infrastructure. If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=342c3744f40b\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IvET1GBz1yvK9MBNm3OOlg.jpeg\"><figcaption>Light signals illuminating the ends of fiber opticÂ wires</figcaption></figure><p>In our <a href=\"https://devsafehouse.medium.com/tcp-vs-udp-whats-the-difference-8ef9616fc14a\">last article</a>, we talked about TCP and UDP, the protocols that handle the delivery and verification of data sent over the internet. In this article we will shift our focus to hardware: how is data passed betweenÂ devices?</p>\n<p><em>Ethernet</em> and <em>Fiber Optics</em> are probably terms youâ€™ve heard before, maybe in advertisements or skimming through E-Bay. You may already know that they have something to do with wired communication. But what are they really, and why is Fiber Optics all the rage now? This article will help you understand!</p>\n<h3>What is Ethernet?</h3>\n<p>Ethernet is a protocol for wired communications. It is most commonly used for Local Area Networks (LAN), i.e. small networks usually controlled by switches. However, the Ethernet protocol can be used for MAN (Metropolitan Area Networks) and WAN (Wide Area Networks) asÂ well.</p>\n<p>First developed by Xerox in 1973, it was standardized in 1980 by the Institute of Electrical and Electronic Engineers (IEEE) and has since gone through many revisions to improve bitrate and power usage. The standard for Ethernet and other wired communication infrastructure (IEEE 802) specify both the type of wire and how data is sent throughÂ it.</p>\n<p>An <em>ethernet cable</em> is a telecommunications cable that meets the IEEE specification. Any cable you use to connect an internet-facing device to a switch or router is most likely an EthernetÂ cable.</p>\n<h3>Old Network CableÂ Types</h3>\n<p>The Ethernet standard has gone through many changes to improve bitrate and power usage. Most significant of these is the type of cable used to transfer theÂ data.</p>\n<h4>Coaxial Cables</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ma8W_Qwet4hjy5KfxSiQ1g.jpeg\"><figcaption>Layers of a coaxial cable (<a href=\"https://frida-cable.en.made-in-china.com/product/zegEUlaKHDVZ/China-Coaxial-Cable-RG58-RG174-RG213-.html\">imageÂ source</a>)</figcaption></figure><p>The first telecommunications cables were known as <em>coaxial</em> (or coax) cables. Coax cables were first used in 1858 but were first patented in 1880 by British mathematician Oliver Heaviside. They were originally used for telegraph, radio and television communications, and 1980 to the 90â€™s were the Ethernet standard for 10Mb/s communication. They came in two varieties: thinnet (10BASE2 standard) or thicknet (10BASE5).</p>\n<p>Coax cables consisted of a conductive wire (usually copper) surrounded by a dielectric layer and a metallic shield, all covered in an insulating jacket. The key benefit of coaxial cables was that the electrical field was contained within the metal shield. However, this is only true for ideal, infinitely smooth coax cables. In the real world, noise and signal leakage was a problem, and the cables were already very stiff. If internet speeds were to improve, another solution wasÂ needed.</p>\n<h4>Twisted PairÂ Cables</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*VoME_LXxAtzz4TiDHwvaqA.jpeg\"><figcaption>Inside a twisted pair cable (<a href=\"https://www.markertek.com/product/bl-1583a/belden-1583a-cat-5e-twisted-pair-cable-per-foot\">imageÂ source</a>)</figcaption></figure><p>Starting in the â€˜90â€™s, the <em>twisted pair </em>design<em> </em>became the most performant Ethernet standard<em>. </em>Twisted pair cables could achieve bitrates from 10Mb/s to 10Gb/s. The 10Mb/s variety was called 10BASE-T or Category 3. The 100Mb/s standards were known as 100BASE-TX, Cat5, and Cat5e. Finally, the 10Gb/s variety was called 10GBASE-T.</p>\n<p>As the name suggests, a twisted pair cable consists of four pairs of copper wires, each twisted in a helix shape. Twisted pair cables can be shielded (STP) or unshielded (UTP). In the shielded version, each pair is given its own insulating jacket, whereas the same is not true for the unshielded version. However, the unshielded version may have a separator or drain wire to achieve the same level of protection. In general, the unshielded variety is more common for costÂ reasons.</p>\n<p>The twisted pair design dramatically increased internet speeds and reduced the problem associated with coax cables. But twisted pair cables are not the most performant cable outÂ there.</p>\n<h3>Fiber Optics</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5bvgeYAgMG1VeZJyyreaOg.jpeg\"><figcaption>Inside a fiber optic cable (<a href=\"https://sikora.net/en/sikora-quality-assurance-at-the-production-of-optical-fiber-cables/\">imageÂ source</a>)</figcaption></figure><p>Time for the mainÂ event!</p>\n<p>Currently, the Ethernet standards with the highest bitrates use fiber optic cables. The standards go up to 100 Gb/s, but the best fiber optic cables support bitrates on the order of terabits. Unlike the previous types of cables, fiber optics is most commonly used for intercontinental, WAN communication.</p>\n<p>What is most interesting about these cables, though, is their design. Instead of electrical signals passing through copper wires, infrared light is passed through threads of glass or plastic. This design is well-suited for long-distance communication because the signals are immune to electromagnetic interference and they taper off lessÂ quickly.</p>\n<p>Fiber optics is nothing new. The first optical fiber was developed in the â€™70s and its use as a communication medium was investigated in the 80s and 90s. It only took off in the 2000â€™s when optical fiber became commercially available. Since then, fiber optic cables have become an integral part of our global telecommunications system. ISPs (Verizon, AT&amp;T, Optimum, etc.) have also invested in providing fiber optic internet to theÂ home.</p>\n<h4>SafeHouse</h4>\n<p>We are currently developing tools to protect your network infrastructure. If you found what you read informative, consider checking us out at <a href=\"https://safehouse.dev/\">https://safehouse.dev/</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=342c3744f40b\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["communication","internet","computer-science","networking","technology"]}]},"__N_SSG":true}